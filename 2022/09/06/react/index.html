<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>react - 文档</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,博客,前端,游戏>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="文档" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">文档</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">react</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2022-09-06</span>
  </div>
  <div class="post-content">
    <h3 id="1-react-响应原理是什么"><a href="#1-react-响应原理是什么" class="headerlink" title="1. react 响应原理是什么?"></a>1. react 响应原理是什么?</h3><p>当组件的状态发生改变时, React 会重新渲染组件,并生成一颗新的虚拟 DOM树. React 会将新的虚拟 DOM 树与旧的虚拟 DOM 树进行比较,找出需要更新的节点, 并进行更新. 这个过程被称为调和.</p>
<p>React 在调和时, 采用了一些优化策略, 例如批量更新, DOMDiff 算法等. 通过这些优化, React 可以快速地更新 DOM, 提供性能</p>
<p>在 React 中, 状态更新是异步的. 当组件的状态发生改变时, React 会将状态的改变放入一个队列中,等到合适的时机再去更新组件. 这个过程被称为批量更新,批量更新可以避免不必要的重渲染,提供性能.</p>
<p>在 React 中, 通过 <code>setState</code>方法来更新组件的状态. <code>setState</code> 方法接受一个对象或函数作为参数, 用于更新组件的状态. 在更新状态时, React 会自动触发组件的重新渲染, 从而更新组件的显示</p>
<p>总的来说, React 的响应式原理是基于虚拟 DOM 和状态更新机制实现的. 通过虚拟 DOM 的比较和更新,React 可以高效的更新组件的显示.而通过状态更新机制. React 可以实现组件的响应式</p>
<h3 id="2-react-如何监听数据变化"><a href="#2-react-如何监听数据变化" class="headerlink" title="2. react 如何监听数据变化"></a>2. react 如何监听数据变化</h3><p>在react 中监听数据变化的方式是通过组件的状态(state) 和属性(props)来实现的.<br>具体来说,可以采用以下几种方式:</p>
<ul>
<li>setState() 方法<br>在 React 中, 通过调用组件的 setState()方法来更新组件的状态, 当调用 setState() 方法时, React 会自动重新渲染组件, 并将更新后的状态传递给组件. 在 setState() 方法中,可以使用回调函数来监听数据的变化,例如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;count has been updated: &#x27;</span>, <span class="built_in">this</span>.state.count);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>componentWillReceiveProps() 生命周期函数<br>在React中, 组件的属性(props) 发生变化时,会触发 componentWillReceiveProps() 生命周期函数. 可以在这个函数中监听数据的变化, 例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.data !== <span class="built_in">this</span>.props.data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data has been updated: &#x27;</span>, nextProps.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>shouldComponentUpdate() 生命周期函数<br>在 React 中, 可以通过 shouldComponentUpdate() 生命周期函数来判断组件是否需要重新渲染. 可以在这个函数中监听数据的变化,例如</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextState.count !== <span class="built_in">this</span>.state.count) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;count has been updated: &#x27;</span>, nextState.count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-react-生命周期"><a href="#3-react-生命周期" class="headerlink" title="3. react 生命周期"></a>3. react 生命周期</h3><ol>
<li>挂载阶段(Mounting): 当组件实例被创建并插入到 DOM 中时执行以下声明周期方法:</li>
</ol>
<ul>
<li>constructor(): 构造函数, 在组件被创建时调用. 在这里可以初始化组件的状态(state)和绑定事件处理函数(bind 方法)等</li>
<li>getDerivedStateFromProps(props,state): 静态方法, 在组件挂载前调用,用于根据传入的 props 更新组件的 state</li>
<li>render(): 渲染函数,将组件的虚拟 DOM 渲染到页面上</li>
<li>componentDidMount(): 组件挂载后执行, 用于执行一些副作用, 如发送数据请求, 添加事件监听器等</li>
</ul>
<ol start="2">
<li>更新阶段(updating): 当组件的 props 或 state 发生变化时执行以下生命周期方法:</li>
</ol>
<ul>
<li>static getDerivedStateFromProps(props, state):静态方法, 在组件更新前调用,用于根据传入的 props 更新组件的 state</li>
<li>shouldComponentUpdate(nextProps,nextState): 在组件更新之前调用,用于判断组件是否需要重新渲染,返回值为 true 或 false</li>
<li>render() : 渲染函数,将组件的虚拟 DOM 渲染到页面上</li>
<li>getSnapshotBeforeUpdate(prevProps,prevState): 在组件更新前调用, 用户获取更新之前的 DOM 信息, 返回值会传递给     componentDidUpdate() 方法的第三个参数</li>
<li>componentDidUpdate(prevProps, prevState, snapshot): 在组件更新后调用，用于执行一些副作用，如更新其他组件、处理 DOM 变更等</li>
</ul>
<ol start="3">
<li><p>卸载阶段(Unmounting): 当组件从 DOM 中移除时执行以下生命周期的方法:</p>
<ul>
<li><p>componentWillUnMount(): 组件卸载前执行,用于取消事件监听器, 清理定时器等<br>除了上述声明周期方法, React 还有一些其他的生命周期方法,如:</p>
</li>
<li><p>static getDerivedStateFromError(error): 静态方法，在组件内部发生错误时调用，用于根据错误更新组件的 state。</p>
</li>
<li><p>componentDidCatch(error, info): 在组件内部发生错误后调用，用于处理错误信息</p>
<h3 id="4-vue-和-react-中父子组件传递有哪些不同"><a href="#4-vue-和-react-中父子组件传递有哪些不同" class="headerlink" title="4. vue  和 react 中父子组件传递有哪些不同?"></a>4. vue  和 react 中父子组件传递有哪些不同?</h3></li>
</ul>
</li>
</ol>
<p>在 Vue 中, 父组件向子组件传递数据通常使用 <code>props</code>, 即将数据以属性的形式传递给子组件. 子组件通过 <code>this.$props</code> 和<code>this.$attrs</code> 来获取父组件传递过来的数据. 另外, Vue 中也可以使用 <code>provide</code> 和<code>inject</code> 来进行跨级组件的数据传递.</p>
<p>在 React 中, 父组件向子组件传递数据也可以使用<code>props</code>, 即将数据以属性的形式传递给子组件. 子组件通过 <code>props</code> 来获取父组件传递过来的数据. 另外, 在React 中也可以使用  <code>context</code>来进行跨级组件的数据传递</p>
<p>Vue 和 React 在父子组件传递数据的方式上有些不同，但是它们的思想是一致的，都是通过组件之间的数据传递来实现组件之间的通信。需要注意的是，在 Vue 中，父组件向子组件传递数据时，数据是单向流动的，即父组件可以向子组件传递数据，但子组件不能直接修改父组件的数据，只能通过 $emit 方法向父组件发送事件来触发父组件的方法从而改变数据。而在 React 中，由于所有的组件都是可变的，因此可以通过回调函数或 context 来实现子组件修改父组件的数据(这个不一定全对)</p>
<h3 id="5-React-如何绑定事件-和-vue-以及原生事件的不同"><a href="#5-React-如何绑定事件-和-vue-以及原生事件的不同" class="headerlink" title="5.React 如何绑定事件, 和 vue 以及原生事件的不同?"></a>5.React 如何绑定事件, 和 vue 以及原生事件的不同?</h3><p>React 的事件机制是基于合成事件实现的.合成事件是 React封装的跨浏览器的事件系统, 它在底层使用了事件委托和事件池来优化性能</p>
<p>事件委托是一种常见的优化手段, 它可以将事件处理函数绑定到容器元素上, 然后在容器元素内部捕获所有事件, 通过判断事件来源来执行相应的事件处理函数. 这个可以避免在每个子元素都绑定事件处理函数. 从而减少内存占用和事件注册时间</p>
<h3 id="6-在-React-中使用-原生事件不能冒泡-React-事件的原因"><a href="#6-在-React-中使用-原生事件不能冒泡-React-事件的原因" class="headerlink" title="6.在 React 中使用 原生事件不能冒泡 React 事件的原因"></a>6.在 React 中使用 原生事件不能冒泡 React 事件的原因</h3><p>在 React 中使用原生事件无法冒泡到 React 组件的事件处理程序，是因为 React 使用了一种叫做“合成事件”的技术来处理事件。合成事件是 React 提供的一种事件系统，它封装了原生事件，并提供了一些额外的功能，比如自动绑定 this、跨浏览器兼容性等。</p>
<p>React 为了提高性能，会在组件的根节点上绑定一些原生事件，例如 onClick、onKeyDown 等。当这些事件被触发时，React 会生成一个合成事件，并调用与之相关联的组件的事件处理程序。合成事件不会冒泡到 DOM 树上，而是通过事件委派的方式交由 React 进行处理。</p>
<p>因此，如果在 React 组件中使用原生事件来处理事件，该事件不会被传递给 React 的事件处理程序。这意味着，无法通过原生事件来触发 React 组件的状态更新、重渲染等操作，也无法与其他 React 组件共享状态。如果需要在 React 组件中使用原生事件，可以通过手动触发 React 组件的事件处理程序来实现</p>
<h3 id="7-react-中对-jsx-的理解"><a href="#7-react-中对-jsx-的理解" class="headerlink" title="7. react 中对 jsx 的理解"></a>7. react 中对 jsx 的理解</h3><p>jsx 是 React 中一种用于描述用户界面的语法, 它允许我们使用类似于 HTML 的标记来描述 ui 组件,并且可以在其中迁入 js 代码, 🙆🏻‍♀️组件的逻辑和渲染可以更加灵活,</p>
<h3 id="8-react-中的-React-createElement-都做了什么"><a href="#8-react-中的-React-createElement-都做了什么" class="headerlink" title="8 . react 中的 React.createElement 都做了什么"></a>8 . react 中的 React.createElement 都做了什么</h3><h3 id="9-ReactDom-render-做了什么呢"><a href="#9-ReactDom-render-做了什么呢" class="headerlink" title="9.ReactDom.render 做了什么呢?"></a>9.ReactDom.render 做了什么呢?</h3><p>ReactDOM.render() 是 React 中的一个核心方法，用于将 React 元素渲染到 DOM 中。<br>它的主要作用是将 React 元素转换为真实的 DOM 节点, 并将其插入到指定的容器中.</p>
<p>具体来说: </p>
<p>ReactDOM,</p>
<h3 id="React-的渲染流程可以分为两个阶段-初始化阶段和更新阶段"><a href="#React-的渲染流程可以分为两个阶段-初始化阶段和更新阶段" class="headerlink" title="React 的渲染流程可以分为两个阶段: 初始化阶段和更新阶段"></a>React 的渲染流程可以分为两个阶段: 初始化阶段和更新阶段</h3><ol>
<li>初始化阶段:<ul>
<li>创建组件: 当 React 遇到组件标签时, 会创建对应的组件实例, 并将组件的 props 传递给组件实例.</li>
<li>解析组件: React 会通过组件实例的 render 方法生成一个 virtual DOM 树(即虚拟 Dom树), 该树包含了组件的结构和状态.</li>
<li>构建 DOM 树: React 会将 虚拟 DOM 树转换为真实的 DOM 树, 并插入到页面中.</li>
<li>注册事件: React 会注册组件中的事件监听器, 并绑定事件处理函数</li>
</ul>
</li>
<li>更新阶段:<ul>
<li>更新状态：当组件的状态发生变化时，React 会重新调用组件的 render 方法生成一个新的 Virtual DOM 树。</li>
<li>Diff 算法：React 会使用 Diff 算法比较新旧 Virtual DOM 树的差异，并更新需要更新的部分。</li>
<li>执行生命周期钩子函数：如果组件的状态发生变化，React 会依次执行组件的生命周期钩子函数，从而触发组件的副作用</li>
<li>React 的渲染流程采用了 Virtual DOM 技术，将组件的状态和视图分离开来，并通过 Diff 算法优化了组件的更新效率，从而提高了应用的性能和用户体验</li>
</ul>
</li>
</ol>
<h3 id="10-React-中-嵌套的组件虚拟-dom-是如何关联的呢"><a href="#10-React-中-嵌套的组件虚拟-dom-是如何关联的呢" class="headerlink" title="10. React  中 嵌套的组件虚拟 dom 是如何关联的呢"></a>10. React  中 嵌套的组件虚拟 dom 是如何关联的呢</h3><p>在 React 中, 每个组件都有自己的虚拟 Dom(也称为”React 元素”), 包括嵌套的组件, 当一个组件嵌套在另外一个组件中时,React 将两个组件的虚拟 Dom 关联在一起, 形成一个树形结构.</p>
<p>具体来说，当一个组件渲染时，它会返回一个虚拟 DOM 树。这个虚拟 DOM 树包含了这个组件及其子组件的所有虚拟 DOM 节点。当这个组件被渲染到页面上时，React 会遍历这个虚拟 DOM 树，并将其转换成实际的 DOM 节点，然后将这些实际的 DOM 节点添加到页面中。</p>
<p>在这个过程中，当 React 遍历到一个嵌套的组件时，它会将这个组件的虚拟 DOM 树插入到父组件的虚拟 DOM 树中，作为父组件的一个子节点。这样，就形成了一个组件树，每个组件都是另一个组件的子节点。</p>
<p>在组件树中，每个组件的虚拟 DOM 树都是相互独立的，但它们之间存在父子关系，这个关系是通过 React 在渲染过程中自动构建和维护的。这也是 React 能够高效地更新页面的关键之一，因为它只会重新渲染发生变化的部分，而不是整个页面。</p>
<h3 id="10-React-组件和虚拟-dom-之间的关系"><a href="#10-React-组件和虚拟-dom-之间的关系" class="headerlink" title="10 React 组件和虚拟 dom 之间的关系"></a>10 React 组件和虚拟 dom 之间的关系</h3><p>React 组件和虚拟 DOM 之间是紧密相关的，可以说虚拟 DOM 是 React 组件工作的基础。下面分别介绍一下它们之间的关系</p>
<ol>
<li><p>React 组件<br>React 组件是 React 应用的核心概念，它是由若干个 React 元素组合而成的。每个组件都有自己的状态（state）和属性（props），以及生命周期方法。在组件中，我们可以通过修改状态或属性来控制组件的行为和渲染输出</p>
</li>
<li><p>虚拟 Dom<br>虚拟 DOM 是 React 中用于优化渲染性能的一种技术，它是 React 组件的一种抽象表示。虚拟 DOM 是一个轻量级的 JavaScript 对象，它描述了组件的结构和属性，但并不是真实的 DOM 节点。</p>
</li>
</ol>
<p>  虚拟 DOM 通过比较前后两个版本的虚拟 DOM 树，找出差异并只对差异部分进行更新，从而避免了直接操作真实 DOM 的开销，提高了渲染性能。<br>3. 组件和虚拟 DOM 之间的关系<br>   React 组件通过 render 方法返回一个描述组件结构和属性的虚拟 DOM。当组件状态或属性发生变化时，React 会比较前后两个版本的虚拟 DOM 树，找出需要更新的部分，并仅仅更新这部分差异，从而实现组件的高效渲染。</p>
<p>   具体来说，当 React 组件状态或属性发生变化时，React 会调用组件的 render 方法生成新的虚拟 DOM 树。然后，React 会比较前后两个版本的虚拟 DOM 树，找出需要更新的部分，生成更新操作并应用到真实 DOM 上。</p>
<p>   因此，可以说 React 组件和虚拟 DOM 是紧密相关的，虚拟 DOM 是 React 组件工作的基础，通过它实现了高效的渲染和更新。</p>
<h3 id="11-React-jsx-和-Vue-的模版的区别"><a href="#11-React-jsx-和-Vue-的模版的区别" class="headerlink" title="11. React jsx 和 Vue 的模版的区别"></a>11. React jsx 和 Vue 的模版的区别</h3><h3 id="12-有状态组件和-无状态组件"><a href="#12-有状态组件和-无状态组件" class="headerlink" title="12. 有状态组件和 无状态组件"></a>12. 有状态组件和 无状态组件</h3><p>自定义 Button 为什么里边可以写文字</p>
<h3 id="组件为什么可以嵌套另外一个组件"><a href="#组件为什么可以嵌套另外一个组件" class="headerlink" title="组件为什么可以嵌套另外一个组件"></a>组件为什么可以嵌套另外一个组件</h3><p>因为在组件中 有 this.props.children,可以将两个括号的内容传递到内部组件,在 React 中</p>
<h3 id="组件传递过去的数据类型"><a href="#组件传递过去的数据类型" class="headerlink" title="组件传递过去的数据类型"></a>组件传递过去的数据类型</h3><ul>
<li><ol>
<li>jsx 可以是一个组件   </li>
</ol>
</li>
<li><ol start="2">
<li>函数, 可以在组件内部调用, 传值出来</li>
</ol>
</li>
<li><ol start="3">
<li>其他正常数据类型</li>
</ol>
</li>
<li><ol start="4">
<li>className 传递样式进去<br>这些都是因为 有 props</li>
</ol>
</li>
</ul>
<h3 id="React-create-后给到了谁"><a href="#React-create-后给到了谁" class="headerlink" title="React.create 后给到了谁?"></a>React.create 后给到了谁?</h3><h3 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h3><h3 id="react-的全家桶"><a href="#react-的全家桶" class="headerlink" title="react 的全家桶"></a>react 的全家桶</h3>
  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2023
  <span class="author">
    weikai
  </span>
</footer>
    </div>
  </body>
</html>