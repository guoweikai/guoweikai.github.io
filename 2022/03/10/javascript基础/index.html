<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>javascript基础 - blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,博客,前端,游戏>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="blog" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">blog</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">javascript基础</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2022-03-10</span>
  </div>
  <div class="post-content">
    <h3 id="1-new-操作符的实现原理"><a href="#1-new-操作符的实现原理" class="headerlink" title="1. new 操作符的实现原理"></a>1. new 操作符的实现原理</h3><ul>
<li>首先创建一个空对象</li>
<li>设置原型，将对象的原型设置为函数的 prototype对象</li>
<li>让函数的this 指向这个对象，执行构造函数的代码</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，就返回这个引用类型的对象(这个地方有疑惑)</li>
</ul>
<p>具体实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ojbectFactory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title">constructor</span> ! == &quot;<span class="title">function</span>&quot;)&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">        result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject,<span class="built_in">arguments</span></span>);</span><br><span class="line">          <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用方法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-map-和-Object-的区别"><a href="#2-map-和-Object-的区别" class="headerlink" title="2 map 和 Object 的区别"></a>2 map 和 Object 的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的健</td>
<td>Map默认情况不包含任何健，只包含显示插入的健</td>
<td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td>
</tr>
<tr>
<td>键的类型</td>
<td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td>
<td>Object 的键必须是 String 或是Symbol。</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td>
<td>Object 的键是无序的</td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可以轻易地通过size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 的键值对个数可以轻易地通过size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
</tbody></table>
<h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3 map和weakMap的区别"></a>3 map和weakMap的区别</h3><p>(1) Map map 本质上就是键值对的集合, 但是普通的 Object 的键值对中的键只能是字符串,而 es6 提供的 map 数据结构类似于对象, 但是它的键不限制范围, 可以是任意类型,<br>是一种更加完美的 hash 结构,如果 map 的键是一个原始数据类型,只要两个键严格相同,就视为是同一个键.</p>
<p>实际上 map 是一个数组, 它的每一个数据也都是一个数组, 其形式如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map =[</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;age&quot;</span>,<span class="number">18</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>map 数据结构有以下操作方法</p>
<blockquote>
<p>size map.size 返回 map 结构的成员总数<br>set(key,value) 设置键名 key 对应的键值 value, 然后返回整个 map 结构, 如果 key 已经有值, 则键值会被更新, 负责就新生成该键,(因为返回的是当前 map 对象, 所以可以链式调用)<br>get(key) 该方法读取 key 对应的键值,如果找不到 key , 返回 undefined<br>has(key) 该方法返回一个布尔值, 表示某个键是否在当前 map 对象中<br>delete(key) 该方法删除某个键, 返回 true ,如果删除失败, 返回 false<br>clear() map.clear() 清楚所有成员, </p>
</blockquote>
<p>（2）WeakMap WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的<br>该对象也有以下几种方法：</p>
<p>set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）<br>get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。<br>has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。<br>delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。<br>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。<br>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。<br>而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。<br>总结：</p>
<p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</p>
<h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4 JavaScript有哪些内置对象"></a>4 JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p>
<p>标准内置对象的分类：</p>
<p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量<br>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等<br>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等<br>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date<br>（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp<br>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array<br>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br>例如 Map、Set、WeakMap、WeakSet<br>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。<br>例如 SIMD 等<br>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等<br>（10）控制抽象对象<br>例如 Promise、Generator 等<br>（11）反射。例如 Reflect、Proxy<br>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等<br>（13）WebAssembly<br>（14）其他。例如 arguments</p>
<p>总结：<br>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象</p>
<h3 id="5-常用的正则表达式有哪些"><a href="#5-常用的正则表达式有哪些" class="headerlink" title="5. 常用的正则表达式有哪些?"></a>5. 常用的正则表达式有哪些?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。<br>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为<br>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。<br>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。<br>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p>
<p>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。<br>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问</p>
<h3 id="7-js-脚本延迟加载的方法有哪些-js-默认是不延迟加载的-默认就是执行到那里就会执行-js-代码"><a href="#7-js-脚本延迟加载的方法有哪些-js-默认是不延迟加载的-默认就是执行到那里就会执行-js-代码" class="headerlink" title="7 js 脚本延迟加载的方法有哪些(js 默认是不延迟加载的, 默认就是执行到那里就会执行 js 代码)"></a>7 js 脚本延迟加载的方法有哪些(js 默认是不延迟加载的, 默认就是执行到那里就会执行 js 代码)</h3><p>延迟加载就是等页面加载完成之后再加载 javascript 文件, js 延迟加载有助于提高页面加载速度<br>一般有以下几种方式(5 种)</p>
<blockquote>
<p>defer 属性  给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样<br>async 属性：给 js 脚本 添加 async 属性, 这个属性会使脚本异步加载,不会阻塞页面的解析过程,但是当脚本加载完成后立即执行 js 脚本, 这个时候如果文档没有解析完成的话同样会阻塞. 多个 async 属性的脚本的执行顺序是不可预测的,一般不会按照代码的顺序依次执行.<br>动态创建  DOM 方式; 动态创建 DOM 标签的方式, 可以对文档的加载事件进行监听, 当文档加载完成后在动态的创建 script 标签来进入 js脚本<br>使用 setTimeout 延迟方法： 设置一个定时器来延迟加载js脚本文件<br>让 JS 最后加载： 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p>
</blockquote>
<h3 id="8-js-类数组对象的定义"><a href="#8-js-类数组对象的定义" class="headerlink" title="8 js 类数组对象的定义"></a>8 js 类数组对象的定义</h3><p>一个拥有 length 属性 和 若干索引属性的对象就可以被称为类数组对象, 类数组对象和数组类似, 但是不能调用数组的方法,常见的类数组对象有 arguments 和 DOM 方法的返回结果, 还有一个函数也可以被看作是类数组对象,因为它含有 length 属性值,代表可接受的参数个数<br>常见的类数组对转为数组的方法有这么几种(因为 类数组对象不能调用数组对象的方法,所以需要将类数组对象转为数组对象)</p>
<ol>
<li><p>slice<br> 最经典的房价,使用 Array 的 slice 方法, 此方法如果不传递参数的话会返回原数组的一个拷贝, 因此可以使用此方法转换类数组到数组<br> var arr = Array.prototype.slice.call(arguments);</p>
</li>
<li><p>Array.from() 天生的可以对类数组对象操作<br>Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例</p>
</li>
</ol>
<h3 id="9-数组有哪些原生方法"><a href="#9-数组有哪些原生方法" class="headerlink" title="9 数组有哪些原生方法"></a>9 数组有哪些原生方法</h3><blockquote>
<p>数组和字符串的转换方法,toString(), toLocalString(), join() 其中 join() 方法可以指定转换为字符串的分隔符.<br>数组尾部操作的方法 pop() 和 push() ,push 方法可以传入多个参数<br>数组首部操作的方法 shift() 和 unshift 重排序的方法 reverse() 和 sort(), sort() 方法可以传入一个函数来进行比较,传入前后两个值,如果返回值为正数,则交换两个参数的位置<br>数组连接的方法 concat(), 返回的是拼接好的数组,不影响原数组,传入的参数可以是数组也可以是字符串,可以传入多个参数<br>数组截取方法 slice,用于截取数组中的一部分返回,<br>数组插入方法 splice(), 影响原数组</p>
</blockquote>
<h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10 Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10 Unicode、UTF-8、UTF-16、UTF-32的区别？</h3><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><p>dom 指的是文档对象模型,它指的是把文档当做一个对象,这个对象主要定义了处理网页内容的方法和接口<br>bom 指的是浏览器对象模型, 它指的是把浏览器当做一个对象来对待, 这个对象主要定义了与浏览器进行交互的方法和接口. bom 的核心是 window , 而 window 对象具有双重角色, 它既是 通过 js 访问浏览器窗口的一个接口, 有事一个 global(全局)对象</p>
<h3 id="14-对类数组对象的理解-如何转化为数组"><a href="#14-对类数组对象的理解-如何转化为数组" class="headerlink" title="14 对类数组对象的理解,如何转化为数组"></a>14 对类数组对象的理解,如何转化为数组</h3><p>  具体可以看问题 8 </p>
<h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15 escape、encodeURI、encodeURIComponent 的区别"></a>15 escape、encodeURI、encodeURIComponent 的区别</h3><ul>
<li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。<br>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。<br>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li>
</ul>
<h3 id="16-对-ajax-的理解-实现一个-ajax-请求"><a href="#16-对-ajax-的理解-实现一个-ajax-请求" class="headerlink" title="16 对 ajax 的理解,实现一个 ajax 请求"></a>16 对 ajax 的理解,实现一个 ajax 请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写,指的是通过 javascript 异步通信,从服务器获取 xml文档从中提取数据,再更新到当前页面的对应部分,而不用刷新这个页面</p>
<p>步骤:</p>
<ol>
<li><p>XMLHttpRequest对象 (xhr):浏览器提供的 js 对象,可以请求服务器上的数据</p>
</li>
<li><p>使用 xhr 发送 get 请求<br>(1) 创建 一个 xhr 对象,一个请求的主体<br>(2) 调用 xhr 的 open函数,参数分别为请求类型和请求主体<br>(3) 调用 xhr 的 send 函数,发起请求<br>(4) 监听 onreadstatechange 事件(请求状态被改变时)<br>请求状态：readyState(4)<br>响应状态：status(200)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  xhr = <span class="keyword">var</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">&quot;方式&quot;</span>,url)</span><br><span class="line">    xhr.send()</span><br><span class="line">    xhr.onreadstatechange =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>  &amp;&amp;  xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3、xhr对象的readyState属性：当前Ajax请求所处的状态</p>
<p>0    UNSENT    XMLHttpRequest对象已被创建，但未调用open方法<br>1    OPENED    open方法已调用<br>2    HEADERS_RECEIVED    send方法已调用，响应头已经被接收<br>3    LOADING    数据接受中，此时response属性中已经包含部分数据<br>4    DONE    Ajax请求完成，数据已经彻底完成或失败</p>
<p>4、使用xhr对象发起带参数的get请求<br>(1) 为 url 地址指定参数即可, url 拼接到后面的参数称为”查询字符串”<br>(2) 查询字符串的格式为: 在 url之后添加问号(?),参数以键值对方式存在<br>（3）get请求方式的本质，需要携带参数时，都是以查询字符串的方式提交参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;请求路径?id=1&#x27;</span>)</span><br><span class="line">xhr.send()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、URL编码（URL只包括英文字母、符号、数字）<br>（1）中文需要编码（转义）<br>（2）编码原则：使用安全字符(英文字符等)表示不安全字符(中文等)，中文字符使用英文字符表示的话是三组%<br>（3）对URL编码与解码</p>
<ul>
<li>编码：encodeURI(要编码的内容)</li>
<li>解码：decodeURI(要解码的内容)</li>
<li>浏览器会自己对中文进行编码和解码<br>6、使用xhr发起post请求</li>
</ul>
<p>（1）创建xhr对象</p>
<p>（2）调用open()函数，指定请求方式和URL地址</p>
<p>（3）调用setRequestheader()，设置Content-Type属性（固定写法，必须写在open之后）</p>
<p>（4）xhr.send()，指定要发送的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;请求路径&#x27;</span>)</span><br><span class="line">xhr.setRequestheader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">xhr.send(<span class="string">&#x27;数据=值&amp;数据=值)</span></span><br><span class="line"><span class="string">xhr.onreadystatechange = function() &#123;</span></span><br><span class="line"><span class="string">  if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span></span><br><span class="line"><span class="string">    console.log(xhr.responseText)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>7、数据交换格式<br>服务器端返回的数据格式是字符串，为了更好的提取返回的信息，返回的字符串有一些特定的格式：XML、JSON</p>
<ul>
<li>XML：标签格式</li>
<li>JSON：像数组、对象的格式</li>
</ul>
<p>8、XML可扩展的标记语言<br>HTML和XML没有关系</p>
<p>HTML是网页内容的载体，XML是用来传输数据的，是数据的载体</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;note&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">to</span>&gt;</span>ls<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">from</span>&gt;</span>zs<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>通知<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>开会<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/note&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>XML缺点：格式臃肿，和数据无关代码多，传输效率低；在JS中解析XML比较麻烦</p>
<p>9、JSON（本质是字符串，是一种具有对象或者数组格式的字符串，也是一种轻量级的文本数据交换格式，更小更快更易解析）</p>
<p>1）JSON的两种结构：</p>
<p>数组&amp;字符串(key必须用英文双印包裹，value只有数字、字符串、布尔值、null、数组、对象6种类型)；数组取值也只有这6种类型</p>
<p>（2）JSON语法注意事项</p>
<p>属性名必须使用双引号包裹；字符串都必须使用双引号；JSON中不能写注释；JSON最外层必须是数组或对象格式；JSON中不允许有undefined和函数等数据</p>
<p>（3）（序列化）JSON字符串转化为JS对象：JSON.parse(json字符串)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27;</span>  <span class="comment">//注意格式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(str))  <span class="comment">// &#123;a: &quot;hello&quot;, b: &quot;world&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>（4）（反序列化）JSON对象转化为JSON字符串：JSON.stringify(js对象)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = &#123;<span class="attr">a</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(str))  <span class="comment">// &#123;&quot;a&quot;:&quot;hello&quot;,&quot;b&quot;:&quot;world&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>11、XMLHttpRequest Level2<br> 新功能: 可以设置HTTP请求时限;可使用FormData对象管理表单数据；可以上传文件;可以获取数据传输的进度信息;<br> (1). 设置http请求时限（timeout属性）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    xhr.timeout = <span class="number">3000</span></span><br><span class="line"><span class="comment">// 请求超时后，会触发超时回调函数，告诉用户请求超时</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;请求超时了&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）FormData对象管理表单数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="comment">// 创建FormData实例</span></span><br><span class="line"><span class="keyword">var</span> fd = <span class="keyword">new</span> FormData()</span><br><span class="line">fd.append(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line">fd.append(<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;20&#x27;</span>)</span><br><span class="line">xhr.send(fd)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fd = <span class="keyword">new</span> FormData()</span><br><span class="line"><span class="comment">// 向fd中添加数据</span></span><br><span class="line">fd.append(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line"><span class="comment">// fd.get(数据名)  获取表单fd中对应的值</span></span><br><span class="line"><span class="built_in">console</span>.log(fd.get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// zs</span></span><br><span class="line"><span class="comment">// 给一个键值对添加多个值</span></span><br><span class="line">fd.append(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line"><span class="comment">// fd中一个数据有多个值时，fd.get(数据名)获取到第一个值</span></span><br><span class="line"><span class="built_in">console</span>.log(fd.get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// zs</span></span><br><span class="line"><span class="comment">// fd中获取同一个数据的多个值时：fd.getAll(数据名)</span></span><br><span class="line"><span class="built_in">console</span>.log(fd.getAll(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// [&#x27;zs&#x27;, &#x27;ls&#x27;]</span></span><br><span class="line"><span class="comment">// 使用set可重置fd中对应数据的值</span></span><br><span class="line">fd.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;ww&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fd.get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// ww</span></span><br><span class="line"><span class="comment">// 删除fd中某个元素</span></span><br><span class="line">fd.delete(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fd.get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>(3) 上传文件功能</p>
<ul>
<li>定义 ui 结构;</li>
<li>验证是否选择了文件;</li>
<li>向 fromData 中追加文件;</li>
<li>使用 xhr 进行上传文件请求;</li>
<li>监听 onreadystatechange </li>
</ul>
<p>获取表单提交的文件：dom.files，如果有文件选中，则长度不为0</p>
<p>(4) 显示文件上传进度：监听xhr.upload.onprogress事件</p>
<p>e.lengthComputable 若为true，才可计算长度</p>
<p>e.loaded 已经传输的字符</p>
<p>e.total 需传输的总字节</p>
<p>传输进度 = Math.ceil(e.loaded / e.total * 100) + ‘%’</p>
<p>(5）jquery实现文件上传<br>上传文件时必须要设置两个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否转化为查询字符串</span></span><br><span class="line"><span class="attr">processData</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 发送到服务器端的数据类型</span></span><br><span class="line"><span class="attr">contentType</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>
<p>可用ajaxStart和ajaxStop设置加载效果</p>
<p>ajaxStart()：请求开始时运行的函数（只能被$(document)调用）</p>
<p>ajaxStop()：请求完成时运行的函数（只能被$(document)调用）</p>
<p>也可用beforeSend和complete代替，更好用</p>
<p>12、axios：网络数据请求，比jquery更轻量，只专注于网络请求</p>
<p>（1）axios发起get请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;url&#x27;</span>, &#123; <span class="attr">params</span>: &#123; <span class="comment">/*参数*/</span> &#125; &#125;).then(callback)</span><br></pre></td></tr></table></figure>
<p>（2）axios发起post请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;url&#x27;</span>, &#123; <span class="attr">data</span>: &#123; <span class="comment">/*参数*/</span> &#125; &#125;).then(callback)</span><br></pre></td></tr></table></figure>
<h3 id="疑惑点"><a href="#疑惑点" class="headerlink" title="疑惑点"></a>疑惑点</h3><ol>
<li><p> new 最后一步</p>
</li>
<li><p>迭代是什么意思，迭代器是什么？  </p>
<p> 迭代是遍历的意思</p>
</li>
<li><p> 数据的传输是json 格式的字符串</p>
</li>
<li><p>问题 uri 和 url 的区别</p>
</li>
</ol>
<p>url +urn   =uri</p>
<p>uri 是 url 的超级</p>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    weikai
  </span>
</footer>
    </div>
  </body>
</html>