<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>vue-router - 文档</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,博客,前端,游戏>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="文档" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">文档</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">vue-router</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2022-12-26</span>
  </div>
  <div class="post-content">
    <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ol>
<li>当加入 vue router 时, 我们需要做的就是将我们的组件映射到路由上, 让 Vue Router 知道在哪里渲染它们, </li>
</ol>
<h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><ol>
<li><p>我们经常需要把某种模式匹配到的所有路由, 全都映射到同个组件. 例如, 我们有一个 User 组件, 对于所有 ID 各不相同的用户, 都要使用这个组件来渲染, 那么, 我们可以在 vue-router 的路由路径中使用”动态路径参数”, 来达到这个效果</p>
</li>
<li><p>一个 路径参数使用冒号: 标记, 当匹配到一个路由时, 参数值会被设置到 this.$route.params, 可以在每个组件内使用. 于是, 我们可以更新 User 的模板, 输入当前用户的 ID</p>
</li>
<li><p>还可以设置多端”路径参数”</p>
</li>
</ol>
<h2 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h2><p> 当使用 路由参数时, 例如从 /user/foo 导航到 /user/bar 原来的组件实例会被复用, 因为两个路由都渲染同个组件, 比起销毁再创建, 复用则显得更高效, 不过, 这也意味着组件的声明周期钩子不会再被调用</p>
<p>复用组件时, 想对路由参数的变化作出响应的话, 可以简单的 watch $route 对象或者使用导航守卫 beforeRouteUpdate(to,from,next)</p>
<h2 id="捕获所有路由或-404-Not-found-路由"><a href="#捕获所有路由或-404-Not-found-路由" class="headerlink" title="捕获所有路由或 404 Not found 路由"></a>捕获所有路由或 404 Not found 路由</h2><p>常规参数只会匹配被 / 分隔的 URL 片段中的字符. 如果想匹配任意路径 , 我们可以使用通配符(*)</p>
<p>404 错误, 也就是说 含有通配符的路由应该放到最后.</p>
<h2 id="高级匹配模式"><a href="#高级匹配模式" class="headerlink" title="高级匹配模式"></a>高级匹配模式</h2><p>可以参考  path-to-regexp</p>
<h2 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h2><p>有时候, 同一个路径可以匹配多个路由, 此时,匹配的有划线就按照路由的定义顺序: 路由定义的越早, 优先级就越高</p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>实际生活中的应用界面, 通常由多层嵌套的组件组合而成, 同样地, URL 中各段动态路径也按照某种结构对应嵌套的各层组件</p>
<p>要注意, 以 / 开头的嵌套路径会被当做跟路径, 这让你充分的使用嵌套组件而无须设置嵌套的路径</p>
<h2 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h2><p>除了使用 <router-link> 组件创建 a 标签来定义导航链接, 我们还可以借助 router 的实例方法, </p>
<p>router.push(location, onComplete?, onAbort?)</p>
<p>注意: 在 vue 实例内部, 你可以通过 $router 访问路由实例. 因此你可以调用 this.$router.push</p>
<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 在 2.2.0+，可选的在 router.push 或 router.replace 中提供 onComplete 和 onAbort 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。在 3.1.0+，可以省略第二个和第三个参数，此时如果支持 Promise，router.push 或 router.replace 将返回一个 Promise。</p>
<p>注意： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)。</p>
<p>router.replace(location, onComplete?, onAbort?)<br>跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录</p>
<p>router.go(n)<br>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。</p>
<p>操作 History</p>
<p>你也许注意到 router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go (opens new window)好像， 实际上它们确实是效仿 window.history API 的。</p>
<p>因此，如果你已经熟悉 Browser History APIs (opens new window)，那么在 Vue Router 中操作 history 就是超级简单的。</p>
<p>还有值得提及的，Vue Router 的导航方法 (push、 replace、 go) 在各类路由模式 (history、 hash 和 abstract) 下表现一致。</p>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/user/:userId&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: User</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;User&lt;/router-link&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这跟代码调用 router.push() 是一回事：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125; &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;view one&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view two&quot;</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view three&quot;</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<p>一个视图使用一个组件渲染, 因此对于同个路由, 多个视图就需要多个组件,确保正确使用 components 配置(带上 s):</p>
<p>嵌套命名视图</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/b&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重定向的目标也可以是一个命名的路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>甚至是一个方法，动态返回重定向目标：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEnter 守卫并不会有任何效果。</p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>“重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b，那么“别名”又是什么呢？</p>
<p>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p>
<p>上面对应的路由配置为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">component</span>: A, <span class="attr">alias</span>: <span class="string">&#x27;/b&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p>
<h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合, 从而使组件只能在某些特定的 URL 上使用,限制了其灵活性</p>
<p>使用 props 将组件和路由解耦:</p>
<p>取代与 $route 的耦合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过 props 解耦</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>: &#123; <span class="attr">default</span>: User, <span class="attr">sidebar</span>: Sidebar &#125;,</span><br><span class="line">      <span class="attr">props</span>: &#123; <span class="attr">default</span>: <span class="literal">true</span>, <span class="attr">sidebar</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。</p>
<h3 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h3><p>如果 props 被设置为 true，route.params 将会被设置为组件属性。</p>
<h3 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h3><p>如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/promotion/from-newsletter&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: Promotion,</span><br><span class="line">      <span class="attr">props</span>: &#123; <span class="attr">newsletterPopup</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/search&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: SearchUser,</span><br><span class="line">      <span class="attr">props</span>: <span class="function"><span class="params">route</span> =&gt;</span> (&#123; <span class="attr">query</span>: route.query.q &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>URL /search?q=vue 会将 {query: ‘vue’} 作为属性传递给 SearchUser 组件。</p>
<p>请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p>
<h2 id="HTML5-History-模式"><a href="#HTML5-History-模式" class="headerlink" title="HTML5 History 模式"></a>HTML5 History 模式</h2><p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p>
<p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [...][label](https:<span class="comment">//flutter.cn/docs/get-started/install/)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一:  hash 模式</li>
</ul>
<ol>
<li>定义 </li>
</ol>
<p>hash 模式是一种把前端路由的路径用 井号拼接在真实 url 后面的模式.当井号 # 后面的路径发生变化时, 浏览器并不会重新发起请求, 而是会触发<br>onhashchange 事件</p>
<ul>
<li><p>hash 变化会触发网页跳转, 即浏览器的前进和后退</p>
</li>
<li><p>hash 可以改变 url, 但是不会触发页面重新加载, 即不会刷新页面,也就是说,所有页面的跳转都是在客户端进行操作. 因此, 这并不算是一次 http 请求, 所以这种模式不利于 SEO 优化. hash 只能修改 # 后面的部分, 所以只能跳转到与当前 url 同文档的 url. </p>
</li>
<li><p>hash 通过 window.onhashchange 的方式, 来监听 hash 的变化,借此实现无刷新跳转的功能</p>
</li>
<li><p>hash 永远不会提交到 server 端</p>
</li>
<li><p>二 history 模式</p>
</li>
</ul>
<ol>
<li>定义</li>
</ol>
<p>history API 是 H5 提供的新特性, 允许开发者直接更改前端路由, 即更新浏览器 URL 地址而不重新发起请求</p>
<ol start="2">
<li>与 hash 的区别</li>
</ol>
<p>我们用一个例子来演示, hash 与 history 在浏览器刷新时的区别.</p>
<p>具体如下</p>
<p>正常页面浏览</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//github.com/xxx 刷新页面</span></span><br><span class="line">https:<span class="comment">//github.com/xxx/yyy 刷新页面</span></span><br><span class="line">https:<span class="comment">//github.com/xxx/yyy/zzz 刷新页面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改造 H5 history 模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/xxx 刷新页面</span></span><br><span class="line">https:<span class="comment">//github.com/xxx/yyy 前端跳转，不刷新页面</span></span><br><span class="line">https:<span class="comment">//github.com/xxx/yyy/zzz 前端跳转，不刷新页面</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>history 的 API</li>
</ol>
<table>
<thead>
<tr>
<th>API</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>history.pushState(data,title [, url])</td>
<td>pushState 主要用于往历史记录堆栈顶部添加一条记录, 各参数解析如下: 1. data 会在 onpopstate 事件触发时作为参数传递过去; 2 title 为页面标题, 当前所有浏览器都会忽略此参数; 3 url 为页面地址, 可选, 缺少时表示为当前页地址</td>
</tr>
<tr>
<td>history.replaceState(data,title[,url])</td>
<td>更改当前的历史记录,参数同上; 上面的 pushstate 是添加, 这个更改</td>
</tr>
<tr>
<td>histroy.state</td>
<td>用于存储以上方法的 data 数据, 不同浏览器的读写权限不一样</td>
</tr>
<tr>
<td>window.onpopstate</td>
<td>响应 pushstate 或者 replaceState的调用</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>4. history 的特点</td>
<td></td>
</tr>
</tbody></table>
<p>对于 history 来说, 主要有以下特点</p>
<ul>
<li>新的 url 可以是与当前 url 同源的任意 url, 也可以是与当前 url 一样的地址, 但是这样会导致的一个问题是, 会吧重新的这一次操作记录到栈当中</li>
<li>通过 history.state 添加任意类型的数据到记录中</li>
<li>可以额外设置 title 属性, 以便后续使用</li>
<li>通过 pushState replaceState 来实现无刷新跳转的功能</li>
</ul>
<ol start="5">
<li>存在问题</li>
</ol>
<p>对于history 来说, 确实解决了不少 hash 存在的问题, 但是也带来了新的问题, 具体如下</p>
<ul>
<li>使用 history 模式时, 在对当前的页面进行刷新时, 此时浏览器会重新发起请求. 如果 后端没有匹配的到当前的 url, 就会出现 404 的页面</li>
<li>而对于 hash 模式来说, 它虽然看着是改变了 url, 但不会被包括在 http 请求中. 所以, 它算是被用来指导浏览器的动作, 并不影响服务器端,因此, 改变 hash 并没有真正的改变 url, 所以页面路径还是之前的路径, nginx 也就不会拦截</li>
</ul>
<ol start="6">
<li>两者的选择</li>
</ol>
<hr>
<p>#进阶</p>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>什么是导航守卫?</p>
<p>实际应用的场景有哪些</p>
<p>正如其名, vue-router 提供的导航守卫主要用来跳转或取消的方式守卫导航. 这里有很多方式植入路由导航中: 全局的, 单个路由独享的, 或者组件级的.</p>
<p>记住参数或查询的改变并不会触发进入/离开的导航守卫, 你可以通过 观察 $route 对象来应对这些变化, 或使用</p>
<p>beforeRouteUpdate 的组件内守卫.</p>
<p>守卫的几种形式?应用场景是哪些</p>
<p>全局前置守卫<br> 你可以使用 router.beforeEach 注册一个全局前置守卫<br> 当一个导航触发时, 全局前置守卫按照创建顺序调用, 守卫是异步解析执行,此时导航在所有守卫 resolve 完之前一直处于等待中</p>
<p> 每个守卫方法接收两个参数</p>
<ul>
<li>to 即将要进入的目标 用一种标准化的方式</li>
<li>from 当前导航正要离开的路由 用一种标准化的方式</li>
<li>next:Function : 一定要调用该方法来 resolve 这个钩子,执行效果依赖 next 方法的调用参数.<ul>
<li>next(): 进行管道中的下一个钩子. 如果全部钩子执行完了, 则导航的状态就是 confirmed</li>
<li>next(false):中断当前的导航,如果浏览器的 url 改变了(可能是用户手动或者浏览器后退按钮),那么 url 地址会重置到 from 路由对应的地址</li>
<li>next(‘/‘)</li>
</ul>
</li>
</ul>
<p>可以返回的值如下:</p>
<ul>
<li>false: 取消当前的导航, 如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮), 那么 URL 地址会重置到 From 路由对应的地址</li>
<li>一个路由地址: 通过一个路由地址跳转到一个不同的地址, 就像你调用 router.push() 一样, 你可以设置诸如 replace:true 或 name:’home’ 之类的配置, 当前的导航被中断, 然后进行一个新的导航,就和 from 一样</li>
</ul>
<h3 id="全局路由钩子"><a href="#全局路由钩子" class="headerlink" title="全局路由钩子"></a>全局路由钩子</h3><p>beforeEach(to,from ,next) , beforeResolve(to,from,next)<br>afterEach(to,from)</p>
<p>问题 全局前置守卫和全局解析守卫的区别?应用场景</p>
<h3 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h3><h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><p>完整的导航解析流程</p>
<ol>
<li>导航被激活</li>
<li>在失活的组件里调用 beforeRouteLeave 守卫</li>
<li>调用全局的 beforeEach 守卫</li>
<li>在重用的组件里调用 beforeRouteUpdate</li>
<li>在路由配置里调用 beforeEnter</li>
<li>解析已补路由组件</li>
<li>在被激活的组件里调用 beforeRouteEnter</li>
<li>调用全局的 beforeResolve 守卫</li>
<li>导航被确认</li>
<li>调用全局的 afterEach 钩子</li>
<li>触发 DOM 更新</li>
<li>调用 beforeRouteEnter 守卫中传给 next 的回调函数, 创建好的组件实例会作为回调函数的参数传入</li>
</ol>
<h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>什么是路由元信息?<br>vue-router 路由元信息说白了就是通过 </p>
<p>使用的场景有哪些?</p>
<h2 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h2><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时, js 包会变得非常大,影响页面加载. 如果我们能把不同路由对应的组件分割成不同的代码块,然后当路由被访问的时候才加载对应组件, 这样就更加高效了</p>
<hr>
<h1 id="api-解析"><a href="#api-解析" class="headerlink" title="api 解析:"></a>api 解析:</h1><h2 id="router-link-props"><a href="#router-link-props" class="headerlink" title="router-link props"></a>router-link props</h2><ul>
<li>to</li>
</ul>
<p>表示目标路由的连接, 当被点击后, 内部会立刻把 to 的值传到 router.push(), 所以这个值可以是一个 string 或者是描述目标位置的对象</p>
<ul>
<li>replace<br>  设置 replace 属性的话, 当点击时, 会调用 router.replace(), 而不是 router.push(),所以导航后不会留下历史记录</li>
</ul>
<ul>
<li>active-class<br> 链接激活时, 应用与渲染的 <a> 的 class</li>
</ul>
<h2 id="router-view-props"><a href="#router-view-props" class="headerlink" title="router-view props"></a>router-view props</h2><p> 如果 <router-view> 设置了名称, 则会渲染对应的路由配置中. components 下的相应组件</p>
<p> Router 构建选项</p>
<p> mode: </p>
<p>配置路由模式:</p>
<ul>
<li>hash:使用 URL hash 值来作为路由,支持所有浏览器,包括不支持 HTML 5 History Api 的浏览器</li>
</ul>
<h2 id="Router-实例属性"><a href="#Router-实例属性" class="headerlink" title="Router 实例属性"></a>Router 实例属性</h2>
  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2023
  <span class="author">
    weikai
  </span>
</footer>
    </div>
  </body>
</html>