<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>Vue面试题 - 文档</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=生活,博客,前端,游戏>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="文档" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">文档</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">Vue面试题</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2023-03-13</span>
  </div>
  <div class="post-content">
    <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol>
<li>谈谈你对 Vue 响应式数据的理解(深入数据响应原理)?<br>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式<br>Vue 响应式数据是 Vue.js 中最重要的概念之一，它是实现 Vue 双向数据绑定的核心机制。在 Vue 中，当我们将一个数据对象传入 Vue 实例中后，Vue 会将这个数据对象进行响应式处理，使得这个数据对象中的数据能够与视图同步更新</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>谈谈你对 Vue 的双向数据绑定?</p>
</li>
<li><p>Vue 中如何检测数组的变化 或者 Vue 如何检测对象的变化 ?</p>
<ol>
<li>当你利用索引直接设置一个数组项时, 例如:<br>vm.items[indexOfItem] = newValue</li>
<li>当你修改数组的长度时, 例如: vm.items.length = newLength</li>
</ol>
<p> <strong>Vue 中 数组的索引和长度变化时无法被监控的</strong><br> 通过重写了数组的 7 个方法,分别是</p>
</li>
<li><p>vue 中如何进行依赖收集</p>
</li>
</ol>
<ol start="5">
<li><p>如何理解Vue中的模板编译原理是什么?<br>这个问题的核心是如何将template转换成render函数。<br>将template模块转换成ast语法书 - parserHTML<br>对静态语法做标记（某些节点不改变）<br>重新生成代码 - codeGen,使用with语法包裹字符串</p>
</li>
<li><p>Vue生命周期钩子是如何实现的?<br>Vue 的生命周期钩子是回调函数, 当创建组件实例的过程中会调用相应的钩子方法. 内部会对钩子进行处理, 将钩子函数维护成数组的形式</p>
</li>
<li><p>Vue的生命周期有哪些?<br> beforeCreate 在实例初始化之后，数据观测observer 和event、watcher事件配置之前被调用<br> created 实例已经创建完成，在这一步，以下配置被完成<br>   数据观测<br>   属性和方法的运算<br>   watch/event时间回调<br>   $el尚未生成<br>   beforeMount 在挂载之前被调用，render尚未被调用<br>   mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用<br>   beforeUpdate 数据更新时，被调用，发生在虚拟Dom重新渲染和打补丁之前<br>   update 由于数据更改导致的虚拟Dom重新渲染和打补丁，在这之后调用<br>   beforeDestroy 实例销毁之前调用<br>   destroyed 实例销毁之后调用，调用后Vue实例的所有东西都会被解绑，所有的事件监听会被移除，子实例被销毁，该钩子在服务端渲染期间不被调用<br>   keep-alive（activated &amp; deactivated）</p>
</li>
<li><p>vue.mixin的使用场景和原理?<br> Vue的mixin的作用就是抽离公共的业务逻辑，原理类似对象的继承，当组件初始化的时候，会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。<br> 如果混入的数据和本身组件的数据有冲突，采用本身的数据为准。<br> 缺点：命名冲突、数据来源不清晰</p>
</li>
<li><p> 请说明 nextTick 的原理</p>
</li>
<li><p>nextTick 中的回调是在下次 Dom 更新循环结束之后执行的延迟回调</p>
</li>
<li><p>可以用于获取更新后的Dom</p>
</li>
<li><p>Vue中的数据更新是异步的，使用nextTick可以保证用户定义的逻辑在更新之后执行</p>
</li>
<li><p>谈谈你对 keep-alive 的了解<br>keep-alive 是 Vue 内置的组件, 可以使被包含的组件保留状态, 避免重新渲染, 其有一下特性:</p>
</li>
<li><p>一版结合路由和动态组件一起使用, 用于缓存组件</p>
</li>
<li><p>提供了 include 和 exclude属性, 两者都支付字符串或正则表达式, include 表示只有名称匹配的组件会被缓存, exclude 表示任何名称匹配的组件都不会被缓存, 其中 exlude 的优先级比 include高; </p>
</li>
<li><p>对应两个钩子函数 activated 和 deactivated, 当组件被激活时, 触发钩子函数 activeted,当组件被移除时, 触发钩子函数 deactived</p>
</li>
<li><p>  组件中 data 为什么是一个函数</p>
</li>
<li><p>vue 中组件是用来复用的, 为了进行 data 复用, 将其定义为函数</p>
</li>
<li><p>vue 组件中的 data 数据都应该是相互隔离, 互补影响的, 组件每复用一次, data 数据就应该被复制一次, 之后,当某一处复用的地方组件内 data 数据被改变时, 其他复用地方组件的 data 数据不会影响, 就需要通过 data 函数返回一个对象作为组件的状态</p>
</li>
<li><p> 当我们将组件的 data 写成一个函数,数据以函数返回值形式定义, 这样每复用一次组件, 就会返回一份新的 data, 拥有自己的作用域,类似于给每个组件实例创建一个私有的数据空间,让每个组件实例维护各自的数据</p>
</li>
<li><p> 当我们组件的 data 单纯的写成对象, 这些实例用的是同一个构造函数.由于 js 的特性所导致, 所有的组件实例共用了一个 data, 就会造成一个变了全部都变的结果.</p>
</li>
</ol>
<pre><code>```
</code></pre>
<ol start="12">
<li><p>  computed和watch的区别是什么？</p>
</li>
<li><p>computed 和 watch都是基于 watcher 来实现的</p>
</li>
<li><p>computed 的属性是具备缓存的, 依赖的值不发生变化, 对其取值时计算属性方法不会重复执行</p>
</li>
<li><p>watch 是监控值的变化, 当值发生改变的时候, 会调用回调函数</p>
</li>
<li><p>Vue.set 方法是如何实现的</p>
<ul>
<li>Vue 给对象和数据本身都添加了 dep 属性</li>
<li>当给对象新增不存在属性的时候,就会触发对象依赖的 watcher 去更新</li>
<li>当修改数组索引的时候, 就调用数组本身的 splice 方法去更新数组</li>
</ul>
</li>
<li><p>Vue 为什么要用虚拟 dom</p>
<ul>
<li>虚拟 dom 就是用 js 对象来描述真实 Dom, 是对真实Dom 的抽象</li>
<li>由于直接操作 dom 性能低, 但是 js 层的操作效率高, 可以将 Dom操作转化成对象操作. 最终通过 diff 算法比对差异进行更新 Dom</li>
<li>虚拟 Dom 不依赖真实平台环境, 可以实现跨平台</li>
</ul>
</li>
<li><p>Vue 中将虚拟 dom 创建成真实 dom?</p>
</li>
<li><p>Vue 的 diff 算法原理是什么?<br>Vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式+双指针方式比较</p>
<ul>
<li>先比较两个节点是不是相同节点</li>
<li>相同节点比较属性,复用老节电</li>
<li>先比较儿子节点,考虑老节点和新节点儿子的情况</li>
<li>优化比较: 头头, 尾尾, 头尾,尾头</li>
<li>比对查找,进行复用</li>
</ul>
</li>
<li><p>既然 vue 通过数据劫持可以精准的探测数据变化, 为什么还要进行 diff 检测差异?<br>Vue 的响应式系统是 push 的代表, 当 Vue 程序初始化的时候就会对数据 data 进行依赖的收集, 一旦数据发生变化,响应式系统就会立刻得知, 因此 Vue 是一开始就知道是(在哪里发生变化了),但是这会又会产生一个问题, 如果你熟悉 vue 的响应式系统就知道, 通常一个绑定一个数据就需要一个 watcher, 一旦我们的绑定细粒度过高就会产生大量的 watcher, 这会带来内存以及依赖追踪的开销, 而细粒度过低会无法精准侦测到发生变化的组件, 然后在组件内部进行 vd Diff 获取更加具体的差异, 而 vd 则是 pull 操作,Vue 是 push+pull 结合的方式进行变化侦测的</p>
</li>
<li><p>请说明 key 的作用和原理(重点总结)</p>
</li>
</ol>
<ul>
<li>Vue 的 patch 过程中, 通过 key 可以判断两个虚拟节点是否相同</li>
<li>没有 key 会导致更新的时候出问题</li>
<li>尽量不要采用索引作为 key</li>
<li><em>key 的使用场景</em>*<br>元素的的复用和重新渲染的区别:<blockquote>
<p>元素的复用是在已经存在的元素上,修改其属性,  元素重新渲染, 是创建一个新的标签</p>
</blockquote>
</li>
<li>在元素切换中, 使用 v-if 和 v-else 切换相同的组件时, vue 为高效地渲染元素, 默认会复用已有的元素而不是重新渲染, 使用不同的 key时,会区别不同的组件</li>
<li>在 transition 过渡中: 使用  v-if 和 v-else 切换时相同的节点, 不添加 key 时, vue 为了效率,会使用同一个元素, 只替换其中的内容, 由于没有元素的插入与删除,所以没有过渡效果,<br>添加了 key,  vue 就不会复用元素了, 正常显示过渡效果</li>
<li>在渲染列表中<ul>
<li>Vue 更新使用 v-for 渲染的元素列表时, 由于无法将之前渲染的元素和新的数据项对应, 默认采用”就地更新”的策略. 如果数据的顺序改变, Vue 不会移动 Dom 元素来匹配数据的顺序, 而是更新每个 DOM 元素的内容,确保渲染内容和在数据中所有的位置一致</li>
<li>为列表的每一个元素添加 key, 列表数据更新顺序时, 会根据 key 找到已渲染的元素进行服用, 对顺序不匹配的元素进行位置调整,更高效</li>
</ul>
</li>
<li><em>v-for 不建议使用 index 作为 key</em>*</li>
</ul>
<ol>
<li>   谈谈对组件的理解    * 组件化开发能大幅提高应用开发效率、测试性、复用性    * 常用的组件化技术：属性、自定义事件、插槽    * 降低更新范围，值重新渲染变化的组件    * 高内聚、低耦合、单向数据流</li>
<li>请描述组件的渲染流程</li>
<li>虚拟 DOM 实现原理<br> 虚拟 DOM 的实现原理主要包括以下 3 部分    * 用 js 对象模拟真实 DOM 树, 对真实 DOM 进行抽象    * diff 算法 - 比较两颗虚拟 DOM 数的差异    * path 算法 - 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树.</li>
<li>虚拟 DOM 的优缺点<br>优点:     * 保证性能下限    * 无需手动操作DOM<br>缺点:<br> 无法进行极致优化</li>
</ol>
<p>  链接<br>  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903918753808398#heading-8">ms1</a>  </p>
<ol start="23">
<li><p>Vue 组件间通信有哪几种方式<br>Vue 组件通信主要包括以下 3 类通信: 父子组件通信, 隔代组件通信, 兄弟组件通信<br>(1) props /$emit 适用父子组件通信<br>这种方法是 Vue 组件的基础<br>(2) ref 与 $parent/ $children 使用父子组件通信</p>
<ul>
<li>ref:如果在普通的 DOM 元素上使用,引用指向的就是 DOM 元素; 如果用在子组件上, 引用就指向组件实例</li>
<li>$parent/ $children: 访问 父/子实例<br>(3) EventBus($emit /$on)<br>这种方法通过一个空的 Vue 实例作为中央事件总线(事件中心), 用它来触发事件和监听事件, 从而实现任何组件间的通信, 包括父子,隔代, 兄弟组件<br>(4) Vuex 使用于父子, 隔代,兄弟组件通信<br>vuex 是一个专为 Vue.js 应用程序开发的状态管理模式, 每一个 Vuex 应用的核心就是 store(仓库).store 基于上就是一个容器, 它包含着你的应用中大部分的状态(state)</li>
</ul>
</li>
<li><p>vue 2 和 vue 3 的区别 ,为什么使用 vue3</p>
</li>
</ol>
<ol start="24">
<li>Vue 组件是 Vue 的实例吗</li>
</ol>
<ol start="25">
<li>Vue 组件如何拆分</li>
</ol>
<ol start="26">
<li>Vue是如何单向数据流的</li>
</ol>
<p>每个子组件都是一个单独的单个, 组件的树形网络关系, 是解析时确定的  比如 parent ,children </p>
<ol start="27">
<li>vue 的模版编译阶段都做了哪些事情<br>将模版字符串编译成 ast , ast 转换成 render 函数<br>在 render 函数中创建了 虚拟 dom<br>通过 renderder 比较新旧 dom ,进行更行</li>
</ol>

  </div>
  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2023
  <span class="author">
    weikai
  </span>
</footer>
    </div>
  </body>
</html>